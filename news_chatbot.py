# -*- coding: utf-8 -*-
"""News Chatbot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/173_9tlxPcaaP3jWXKtogE9b0EcXTNWXG

#**Project Overview**

###**Objective**

The goal of the News Chatbot project is to create an AI-powered chatbot capable of:

1.Reading and summarizing news articles.

2.Generating potential headlines for the article.

3.Engaging in interactive conversations about the article based on user queries.

###**Key Features**
*Text Summarization:* Uses Cohere’s API to condense lengthy news articles into concise summaries.

*Headline Generation:* Employs OpenAI’s GPT model to suggest creative and relevant headlines.

*Dynamic Conversations:* Allows users to ask questions or discuss topics from the article, with OpenAI powering natural and coherent responses.

*Multiple News Domains:* Supports conversations around various news topics, such as politics, sports, nature, and more.

###**Technology Stack**
*Python:* Core programming language.

*Flask:* Web framework for creating API endpoints.

*Cohere API:* For summarizing news articles.

*OpenAI API:* For headline generation and handling dynamic user interactions.

*Google Colab:* Development environment.

*Heroku:* Optional deployment platform for hosting the chatbot as a web service.
###**Use Case**
This chatbot can be integrated into news websites or used as a standalone app, helping users to quickly digest news content, engage with information interactively, and stay informed with meaningful insights. The chatbot provides utility to those looking to efficiently stay updated without reading lengthy articles.

# Importing a library that is not in Colaboratory


Setting Up the the Environment In Google Colab
"""



# Step 1: Create the directory and .env file

!mkdir /content/news-chatbot # create the directory first
# Step 1: Create the directory and .env file

import os

# Create the directory first
os.makedirs("/content/news-chatbot", exist_ok=True)  # Use os.makedirs to avoid error if the directory already exists

# Create the .env file
with open("/content/news-chatbot/.env", "w") as f:
    f.write("# Please add your API keys below:\n")
    f.write("OPENAI_API_KEY=<Your_OpenAI_API_Key_Here>\n")  # Placeholder for actual API key
    f.write("COHERE_API_KEY=<Your_Cohere_API_Key_Here>\n")  # Placeholder for actual API key

print(".env file created. Please update it with your actual API keys.")

!pip install python-dotenv
import os
from dotenv import load_dotenv # import the load_dotenv function from the dotenv module

load_dotenv("/content/news-chatbot/.env")  # Specify the path to the .env file

# Step 4: Retrieve API keys from environment variables
openai_api_key = os.getenv("OPENAI_API_KEY")
cohere_api_key = os.getenv("COHERE_API_KEY")

# Step 5: Check if API keys are properly loaded
print(f"OpenAI API Key: {openai_api_key}")
print(f"Cohere API Key: {cohere_api_key}")

if not openai_api_key or not cohere_api_key:
    raise ValueError("API keys are missing. Ensure OPENAI_API_KEY and COHERE_API_KEY are set in environment variables.")

# Step 2: Install required packages
!pip install openai cohere flask python-dotenv

# Step 3: Import necessary libraries
import os
import openai
import cohere
from flask import Flask, request, jsonify
from dotenv import load_dotenv

# Step 4: Load environment variables from .env file
load_dotenv()

# Step 5: Retrieve API keys from environment variables
openai_api_key = os.getenv("OPENAI_API_KEY")
cohere_api_key = os.getenv("COHERE_API_KEY")

# Step 6: Check if API keys are properly loaded
if not openai_api_key or not cohere_api_key:
    raise ValueError("API keys are missing. Ensure OPENAI_API_KEY and COHERE_API_KEY are set in environment variables.")

# Step 7: Set API keys for OpenAI and Cohere
openai.api_key = openai_api_key
co = cohere.Client(cohere_api_key)

# Step 8: Initialize the Flask app
app = Flask(__name__)

# Step 9: Helper function to generate headlines using Cohere
def generate_headlines(article_text):
    cohere_response = co.generate(
        model='xlarge',
        prompt=f"Generate 3 interesting headlines for the following news article: {article_text}",
        max_tokens=100,
        temperature=0.8,
        num_generations=3
    )
    headlines = [generation.text.strip() for generation in cohere_response.generations]
    return headlines

# Step 10: Helper function to detect article tone using OpenAI
def detect_tone(article_text):
    openai_response = openai.Completion.create(
        model="text-davinci-003",
        prompt=f"Determine the tone of this article: {article_text}. Is it political, crime, sports, tourism, or something else?",
        max_tokens=60,
        temperature=0.6
    )
    tone = openai_response.choices[0].text.strip()
    return tone

# Step 11: Helper function to summarize the article using OpenAI
def summarize_article(article_text):
    openai_response = openai.Completion.create(
        model="text-davinci-003",
        prompt=f"Summarize the following news article in 3-4 sentences: {article_text}",
        max_tokens=150,
        temperature=0.5
    )
    summary = openai_response.choices[0].text.strip()
    return summary

# Step 12: Route to handle chatbot interactions
@app.route('/chat', methods=['POST'])
def chat():
    try:
        # Get the article text and user query from the request
        article_text = request.json.get('article')
        user_query = request.json.get('query')

        if not article_text:
            return jsonify({'error': 'No article text provided'}), 400

        if not user_query:
            return jsonify({'error': 'No query provided'}), 400

        # Generate headlines
        headlines = generate_headlines(article_text)

        # Detect the tone of the article
        tone = detect_tone(article_text)

        # Summarize the article
        summary = summarize_article(article_text)

        # Dynamic conversation with the user based on the context of the article
        conversation_prompt = f"The article is about: {summary}. Now, here's the user's question: {user_query}. Provide a response based on the article's content."
        openai_response = openai.Completion.create(
            model="text-davinci-003",
            prompt=conversation_prompt,
            max_tokens=150,
            temperature=0.7
        )
        dynamic_response = openai_response.choices[0].text.strip()

        # Combine all results into a response
        response = {
            'headlines': headlines,
            'tone': tone,
            'summary': summary,
            'dynamic_response': dynamic_response
        }

        return jsonify(response), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Step 13: A simple route to check if the API is running
@app.route('/', methods=['GET'])
def index():
    return jsonify({'message': 'Welcome to the News Chatbot API'}), 200

# Step 14: Run the Flask app
# Note: Flask app running may not be possible in Colab directly,
# You might need to use ngrok or similar tools to expose your local server.
if __name__ == '__main__':
    app.run(debug=True)

from google.colab import files

# Define the project directory
project_dir = '/content/news-chatbot'
# Create the index.html file
index_html = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>News Chatbot</title>
</head>
<body>
    <div class="container">
        <h1>News Chatbot</h1>
        <textarea id="article" placeholder="Enter the news article here..."></textarea>
        <input type="text" id="query" placeholder="Ask your question...">
        <button id="submit">Submit</button>
        <div id="response"></div>
    </div>
    <script src="script.js"></script>
</body>
</html>
"""

# Create the style.css file
style_css = """body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    margin: 0;
    padding: 20px;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    background-color: #fff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

textarea {
    width: 100%;
    height: 200px;
    padding: 10px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
}

input[type="text"] {
    width: 100%;
    padding: 10px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
}

button {
    background-color: #008CBA;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#response {
    margin-top: 20px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
}
"""
#This code defines the `style_css` variable as a multi-line string containing CSS code, ensuring that the CSS is properly formatted within the string.

# Create the script.js file
# Assuming you are trying to embed javascript code within a python notebook cell, it won't execute directly.
# You would need to serve this code in a browser environment for it to run.
# This code is syntactically correct javascript though.

script_js = """
document.getElementById('submit').addEventListener('click', async function() {
    const article = document.getElementById('article').value;
    const query = document.getElementById('query').value;

    if (!article || !query) {
        alert("Please enter both the article and your question.");
        return;
    }

    const responseDiv = document.getElementById('response');
    responseDiv.innerHTML = 'Loading...';

    try {
        // Dynamically build the fetch URL
        const fetchUrl = `${window.location.origin}/chat`;  // Adjusts based on the current origin

        const response = await fetch(fetchUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ article, query }),
        });

        const data = await response.json();
        if (response.ok) {
            responseDiv.innerHTML = `
                <h2>Response</h2>
                <p><strong>Headlines:</strong> ${data.headlines.join(', ')}</p>
                <p><strong>Tone:</strong> ${data.tone}</p>
                <p><strong>Summary:</strong> ${data.summary}</p>
                <p><strong>Dynamic Response:</strong> ${data.dynamic_response}</p>
            `;
        } else {
            responseDiv.innerHTML = '<p>Error: ' + data.error + '</p>';
        }
    } catch (error) {
        responseDiv.innerHTML = '<p>Error: ' + error.message + '</p>';
    }
});
"""

# Create the project directory
import os
os.makedirs(project_dir, exist_ok=True)

# Write the HTML, CSS, and JavaScript files
with open(f'{project_dir}/index.html', 'w') as f:
    f.write(index_html)

with open(f'{project_dir}/style.css', 'w') as f:
    f.write(style_css)

with open(f'{project_dir}/script.js', 'w') as f:
    f.write(script_js)

# 1. Create app.py
app_py_content = """from flask import Flask, request, jsonify
import cohere
"""

import openai # Make sure to import the openai module
import os

# Initialize Flask app
app = Flask(__name__)

# Set the project directory (replace with your desired directory)
project_dir = "/content/news-chatbot"

# Write the content of app.py to a file
with open(f'{project_dir}/app.py', 'w') as f:
    f.write(app_py_content)

# 2. Create requirements.txt
requirements_txt_content = """flask
cohere
openai
gunicorn # Added gunicorn to the string literal
requests
beautifulsoup4"""

# Set the project directory (replace with your desired directory)
project_dir = "/content/news-chatbot"

with open(f'{project_dir}/requirements.txt', 'w') as f:
    f.write(requirements_txt_content)

# 3. Create Procfile
procfile_content = """web: gunicorn app:app"""


with open(f'{project_dir}/Procfile', 'w') as f:
    f.write(procfile_content)

# 4. Create runtime.txt
runtime_txt_content = """python-3.10.6"""

with open(f'{project_dir}/runtime.txt', 'w') as f:
    f.write(runtime_txt_content)

from google.colab import files

# Download each file
# files.download(f'{project_dir}/app.py') # This file does not exist
files.download(f'{project_dir}/requirements.txt')
files.download(f'{project_dir}/Procfile')
files.download(f'{project_dir}/runtime.txt')
files.download(f'{project_dir}/.env')
files.download(f'{project_dir}/index.html')
files.download(f'{project_dir}/style.css')
files.download(f'{project_dir}/script.js')
files.download(f'{project_dir}/app.py')